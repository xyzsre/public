
README GLB

LAB ğŸ‘

Think of a **Global HTTP Load Balancer** as a pipeline:

**Client â†’ Anycast IP â†’ Forwarding Rule â†’ Target Proxy â†’ URL Map â†’ Backend Service â†’ Instance Groups â†’ VMs**

---

## ğŸŒ Global Entry Point

### **135. Create global static IP (Anycast)**

**Why:**
Gives you **one global IP** reachable worldwide. Google routes users to the **nearest healthy region** automatically.

---

### **136. Verify global IP**

**Why:**
Confirm IP was created and note it for DNS or testing.

---

## â¤ï¸ Health & Backend Logic

### **137. Create global HTTP health check**

**Why:**
The load balancer **must know which VMs are healthy**.
Only healthy instances receive traffic.

---

### **138. Create global backend service**

**Why:**
Backend service is the **logical container** that:

* Holds instance groups
* Applies health checks
* Controls load balancing behavior

---

## ğŸŒ Multi-Region Awareness

### **139. Check region availability zones**

**Why:**
Ensures you create resources in **valid zones** for that region.

---

### **140. Start existing instances**

**Why:**
Load balancer can only route traffic to **running VMs**.

---

## ğŸ–¥ï¸ Backend Compute (Germany region)

### **141â€“142. Create web3 & web4 VMs**

**Why:**
These are your **actual web servers** that will serve HTTP traffic.

---

## ğŸ“¦ Instance Groups (Required by LB)

### **143. Create unmanaged instance group (web3)**

**Why:**
HTTP(S) Load Balancers **cannot point directly to VMs**.
They require **instance groups**.

---

### **144. Add web3 to its group**

**Why:**
Registers the VM as a **load-balanced backend**.

---

### **145â€“146. Repeat for web4**

**Why:**
Enables **horizontal scaling and redundancy** within a region.

---

## â¤ï¸ Health Check ()

### **Create health check (web-hc)**

**Why:**
Same reason as earlier:
Backend service **must reference a health check** to function.


---

## ğŸ“¦ Backend Service (Core Component)

### **Create backend service**

**Why:**
This is the **brain of the load balancer**:

* Knows *how* to send traffic
* Knows *where* to send traffic
* Knows *who is healthy*

---

## ğŸ”— Attach Compute to Backend

### **147â€“148. Add instance groups to backend**

**Why:**
This step **connects real servers to the LB**.
Without this â†’ backend exists but serves nothing.

---

## ğŸ§­ Traffic Routing Logic

### **149. Create URL map**

**Why:**
Defines **routing rules** (path-based, host-based).
Even simple setups require one.

---

### **150. Create HTTP target proxy**

**Why:**
Terminates HTTP connections and:

* Applies URL map logic
* Forwards traffic to backend service

---

## ğŸš¦ Public Exposure

### **151. Create global forwarding rule**

**Why:**
Binds:

* Global IP
* Port 80
* Target proxy

This is what makes the load balancer **publicly reachable**.

---

### **152. Verify forwarding rules**

**Why:**
Ensures the LB is:

* Global
* Listening
* Correctly attached

---

## ğŸ” Validation & Testing

### **153. List running instances**

**Why:**
Confirms all backends are **up and ready**.

---

### **154. Test load balancer**

**Why:**
Verifies:

* Traffic reaches the LB
* Requests are distributed
* No timeouts or failures

---

### **155. Check backend health**

**Why:**
Confirms LB sees instances as **HEALTHY**.
Unhealthy backends receive **zero traffic**.

---

## ğŸŒ Application Layer

### **156â€“157. Install nginx**

**Why:**
Provides actual HTTP content so:

* Health checks succeed
* Clients receive real responses

---

## ğŸ§  One-Line Architecture Summary

| Component       | Purpose                      |
| --------------- | ---------------------------- |
| Global IP       | Single worldwide entry point |
| Forwarding Rule | Listens on port 80           |
| Target Proxy    | Handles HTTP                 |
| URL Map         | Routing logic                |
| Backend Service | Load balancing brain         |
| Health Check    | Determines health            |
| Instance Groups | Backend targets              |
| VMs             | Serve content                |

---

